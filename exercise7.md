## Нагрузочное тестирование ##

**Нагрузочное тестирование (англ. load testing)** — подвид тестирования производительности, сбор показателей и определение производительности и времени отклика программно-технической системы или устройства в ответ на внешний запрос с целью установления соответствия требованиям, предъявляемым к данной системе (устройству).

В общем случае под нагрузочным тестированием понимается практика моделирования ожидаемого использования приложения с помощью эмуляции работы нескольких пользователей одновременно. Таким образом, подобное тестирование больше всего подходит для многопользовательских систем, чаще — использующих клиент-серверную архитектуру (например, веб-серверов). Однако и другие типы систем ПО могут быть протестированы подобным способом. Например, текстовый или графический редактор можно заставить прочесть очень большой документ; а финансовый пакет — сгенерировать отчёт на основе данных за несколько лет. Наиболее адекватно спроектированный нагрузочный тест даёт более точные результаты.

В идеальном случае в качестве критериев успешности нагрузочного тестирования выступают требования к производительности системы, которые формулируются и документируются на стадии разработки функциональных требований к системе до начала программирования основных архитектурных решений. Однако часто бывает так, что такие требования не были четко сформулированы или не были сформулированы вовсе. В этом случае первое нагрузочное тестирование будет являться пробным (англ. exploratory load testing) и основываться на разумных предположениях об ожидаемой нагрузке и потреблении аппаратной части ресурсов.

Одним из оптимальных подходов в использовании нагрузочного тестирования для измерений производительности системы является тестирование на стадии ранней разработки. Нагрузочное тестирование на первых стадиях готовности архитектурного решения с целью определить его состоятельность называется 'proof-of-concept' тестированием.

## Тестирование на отказоустойчивость ##
**Тестирование на отказоустойчивость (Fault Tolerance Testing)** — это процесс проверки надежности и стабильности программного обеспечения при возникновении сбоев, ошибок или непредвиденных ситуаций. Цель данного вида тестирования — определить способность системы продолжать работу и восстанавливаться после возникновения проблем.

**Процесс тестирования на отказоустойчивость**

Процесс тестирования на отказоустойчивость включает в себя следующие этапы:

1. **Анализ требований** — вначале определяются требования к отказоустойчивости системы.
2. **Проектирование тестов** — на этом этапе разрабатываются тестовые сценарии, которые проверяют работу системы в различных условиях.
3. **Подготовка среды тестирования** — подготавливается среда, в которой будет проводиться тестирование (включая аппаратное и программное обеспечение).
4. **Выполнение тестов** — тесты выполняются согласно разработанным тестовым сценариям.
5. **Анализ результатов** — результаты тестов анализируются и документируются. Если обнаружены проблемы, они передаются на доработку разработчикам.

## Стресс-тестирование ##

**Стресс-тестирование** — процесс тестирования программного или аппаратного обеспечения на стабильность в условиях высокой нагрузки. Определяются пределы выносливости системы, при которых она выходит из строя. Чаще всего это некое количество одновременных пользователей/запросов к серверу. После этого оценивают качество обработки системой такой ситуации.

***Стресс-тестирование должно:***

- Проверить поведение системы в «ненормальных» условиях, при экстремальной нагрузке
- Определить цифровые значения одновременных пользователей/запросов к системе, при которых она выходит из строя
- Помочь найти способы нормально отработать ошибки, в первую очередь выдавая релевантные сообщения о них
- Лучше подготовить систему к возможным экстремальным условиям, в том числе проведением упреждающих мер типа улучшения ее кода, «чистки» баз данных, и подобные коррекционные действия 
- Проверить «подпороговое» поведение системы, то есть не превышающее лимиты выносливости, но уже близко к ним; особенно что касается пользовательских данных — повреждаются ли они и в каком объеме, теряются или сохраняются, и пр.
- Помочь обезопасить систему от внешних угроз, поскольку нередко именно в «сверхнагруженных» условиях в системе начинаются внешние атаки

**Стратегия стресс-тестирования**

Такое тестирование типологически относится к нефункциональному тестированию, поэтому проводится после функциональных тестов. Тест-кейсы, подходы и инструменты зависят от приложения/сайта, и выбираются ситуативно. 

Вместе с тем, существуют общие правила (далее стратегия стресс-тестирования веб-приложения в ее общем, «эконом-варианте»):

- Определение сценариев и функций, которые будут «нагружены» более всего, и могут вызвать отказ всей системы
- Определение нагрузки на систему в разные дни, минимальное и максимальное значение
- Создание тест-плана, сценариев, тест-кейсов, и тест-сьютов
- Проведение стресс-тестов на 3-4 компьютерах с разной аппаратной конфигурацией (процессор, объем памяти и пр.)
- Проведение стресс-тестирования веб-приложения на 3-4 разных браузерах
- Желательно уточнить не только саму «точку отказа», но и значения «немного ниже» и «немного выше» (когда система уже точно не отвечает), контролируя окружение и соответствующие тестовые данные
- Для веб-приложений желательно также проверить поведение системы при низкой скорости подключения
- Не спешить с выводами после 1-2 циклов нагрузки, нужно как минимум 5 циклов
- Определить «идеальное время ответа» сервера и время ответа при достижении «точки отказа»
- Оценить поведение системы в «точке отказа» для разных частей/функций — запуск, входы (логины) пользователей, основные функции

## **Отличия нагрузочного тестирования, тестирования на отказоустойчивость и стресс-тестирования** ##
Нагрузочное тестирование позволяет проверить работоспособности системы, варьируя постепенный рост нагрузки от минимальной до пиковой, создавая ожидаемую нагрузку на сервер. Стресс-тестирование отличается от нагрузочного тем, что нагрузка может эмулироваться на протяжении длительного промежутка времени. Тестирование отказоустойчивости позволяет проверить поведение системы в случае сбоя серверов или при других неблагоприятных факторах.

## Пример выполнения нагрузочного тестирования ##

В тестовом наборе будет несколько сценариев. Сценарии будут состоять из этапов, каждому из которых соответствует какое-то количество пользователей (в терминологии нагрузочного тестирования — потоков, или виртуальных пользователей, или VU—пользователей). Виртуальные VU-пользователи будут направлять трафик в приложение.

Также задается так называемая скорость роста пользователей, и скорость снижения. Это показатель ступенчатого роста и снижения количества новых одновременных пользователей в приложении.

Приложение тестируется в двух условиях нагрузки.

_При реалистичной нагрузке_

Когда приложение идет в релиз, нужно удостовериться, что оно способно выдержать какой-то приемлемый трафик. Для этого проводится анализ паттернов поведения пользователей (как они обычно работают с приложением), и создать тестовые сценарии, имитирующие реальное поведение.

_При пиковой нагрузке_

Тестирование в пиковых условиях задействует те же сценарии что в реальных, но с другими параметрами. Количество одновременных пользователей повышают выше реалистичных значений, пока приложение не перестанет отвечать на запросы. Такая нагрузка считается максимальной емкостью приложения.

**Сбор начальных данных для сценариев**

Тестовым сценариям требуется ввод каких-то данных, имитирующих паттерны поведения реальных пользователей. Для этого нужно поставить следующие вопросы:

1. Какое максимальное количество одновременных пользователей ожидается?
Если веб-приложение является заменой или апгрейдом уже существующего приложения, это намного проще. Уже можно знать примерные количества пользователей, которые будут реалистичными.

Идем на страницу «Сессии» или «Пользователи» в приложении аналитики посещаемости (той же Google Alalytics, Яндекс.Метрике и т.п.)
Находим самый нагруженный день за последний год.
В этом дне, выделяем 2 самых нагруженных часа.
Из этих цифр посещаемости, вычисляем количество одновременных пользователей, по формуле:
Количество одновременных пользователей = (количество пользователей за 2 часа) * среднее время проведенное на странице, в секундах  / 3600 секунд / 2 часа = ?

Так мы находим количество одновременных пользователей в самом нагруженном дне за последний год, и это будет наш искомый параметр для расчета нагрузки в реалистичных условиях.

В нашем случае, у нас было 20 тысяч сессий, а среднее время проведенное на странице составило 2 минуты. В итоге получилось 333 одновременных пользователя.

Всего сессий за 2 часа = 20 000 сессий

Среднее время проведенное на странице = 120 секунд

Одновременных пользователей = 333 пользователя

2. Какие части веб-приложения нагружаются больше всего?

Это важно знать, чтобы сбалансировать части приложения, базируясь на реалистичных ожиданиях. 

Например если главная страница принимает больше всего трафика, то тестовый набор должен в первую очередь оценивать главную страницу. Опять же, для этого нужно внимательно посмотреть соответствующий раздел в Google Analytics.

Анализ может выглядеть примерно так (сайт магазина):

| Страница | Процент трафика |
| ------ | ------ |
| / | 60 %|
| /articles | 20% |
| /shop | 15 % |
| /contact | 5 % |

**Проверяем пределы выносливости приложения**

Теперь нужно знать предел, на котором приложение перестает отвечать на тестовые запросы.

Сколько времени приложению нужно, чтобы обработать запрос?
Какой ответ считается успешным?

| Максимальное время ответа | 30 секунд |
| ------ | ------ |
| Успешный ответ (HTTP-код) | HTTP 200, 201, 301, 302, 308 |

Эти пределы должны быть испытаны в тестовом наборе.

**Создание тестовых сценариев**

Когда уже есть вводные данные, можно приступать к написанию тестовых сценариев. Набор надо отконфигурировать, вводя в него эти сценарии, и затем вывести результаты отдельно по каждому, чтобы было проще анализировать результаты.

В таблице ниже — 3 сценария реалистичной нагрузки, и 3 сценария пиковой нагрузки. При пиковой нагрузке количество одновременных пользователей увеличивается “по ступенькам”, таким образом и оценивается устойчивость приложения.

Нужен также “нулевой сценарий”, когда пользователь только один. Тогда имеем прямую линию, “базовую”, она нужна чтобы видеть “базовое” время ответа при отсутствии нагрузки. “Базовая линия” позволяет оценить влияние скачкообразных повышений нагрузки.

| Сценарий | Одновременное количество пользователей | Время роста нагрузки | Длительность нагрузки |
| ------ | ------ |------ | ------ |
| Один пользователь |  1| 	0 минут | 5 минут | 
| Реалистичные условия #1 | 100 | 5 минут | 20 минут |
| Реалистичные условия #2 | 200 |10 минут | 30 минут |
| Реалистичные условия #3 | 350 | 20 минут | 60 минут |
| Пиковые условия #1 | 300 | 10 минут | 30 минут |
| Пиковые условия #2 | 400 | 15 минут | 40 минут |
| Пиковые условия #3| 600 | 20 минут | 50 минут |

**Выполнение тестов**

После создания плана, и написания скриптов, выполняются тесты.

При этом надо учесть следующее:

- Запускаться тестовый набор должен на сервере достаточной мощности, способном генерировать пиковую нагрузку на веб-приложение
- Наладить мониторинг в реальном времени, чтобы сразу видеть последствия нагрузки; как высокий трафик влияет на веб-приложение и другие части сервера
- Тестировать приложение в продакшн-среде, или среде, сопоставимой по мощности
- Выполнять нагрузочное тестирование надо с привлечением разработчиков приложения, чтобы они видели как приложение себя ведет при пиковой нагрузке

## Пример выполнения тестирования на отказоустойчивости ##

Объектом тестирования в большинстве случаев являются весьма вероятные эксплуатационные проблемы, такие как:

1. Отказ электричества на компьютере-сервере
2. Отказ электричества на компьютере-клиенте
3. Незавершенные циклы обработки данных (прерывание работы фильтров данных, прерывание синхронизации)
4. Объявление или внесение в массивы данных невозможных или ошибочных элементов
5. Отказ носителей данных.

Данные ситуации могут быть воспроизведены, как только достигнута некоторая точка в разработке, когда все системы восстановления или дублирования готовы выполнять свои функции. 

Технически реализовать тесты можно следующими путями:

- Симулировать внезапный отказ электричества на компьютере (обесточить компьютер)
- Симулировать потерю связи с сетью (выключить сетевой кабель, обесточить сетевое устройство)
- Симулировать отказ носителей (обесточить внешний носитель данных)
- Симулировать ситуацию наличия в системе неверных данных (специальный тестовый набор или база данных)

При достижении соответствующих условий сбоя и по результатам работы систем восстановления, можно оценить продукт с точки зрения тестирования на отказ. Во всех вышеперечисленных случаях, по завершении процедур восстановления, должно быть достигнуто определенное требуемое состояние данных продукта: _потеря или порча данных в допустимых пределах; отчет или система отчетов с указанием процессов или транзакций, которые не были завершены в результате сбоя._


## Пример выполнения стресс-тестирования ##

Имеем например CRM-приложение автоматизации продаж, которое может выдержать максимально 50000 одновременных пользователей. А если увеличить нагрузку до 51000, параллельно выполняя транзакции обновления или добавления записей в БД? После каждой транзакции приложение должно синхронизироваться с БД. Если все прошло без проблем, нагрузка увеличивается до 52000, и т.п.

**Инструменты для проведения нагрузочного тестирования базы данных**

> Apache JMeter
> 
> LoadRunner
> 
> LoadNinja
> 
> WebLOAD
> 
> LoadUI Pro
> 
> BlazeMeter
> 
> K6
> 
> Яндекс.Танк
> 
> Gatling
> 
> Boomq.io


## **Способы оптимизации (улучшения производительности) базы данных** ##

**Улучшение вычислительных мощностей самого сервера**

Чтобы увеличить объем вычислительных ресурсов на сервере, можно выбрать процессор с более высокой частотой ядер или с большим количеством ядер. Если мощность ЦП является дефицитным ресурсом в системе, увеличение частоты ядер в 2 раза обычно больше повышает производительность, чем удвоение числа ядер с сохранением частоты. Чем лучше процессор, тем быстрее и эффективнее будет база данных. Поэтому, если база данных работает не так, необходимо рассмотреть возможность обновления процессорного модуля более высокого класса; чем мощнее процессор, тем меньше нагрузка при работе с несколькими приложениями и запросами. Кроме того, при оценке производительности ЦП важно отслеживать все аспекты производительности ЦП, в том числе время готовности ЦП (которое может рассказать о случаях, когда система пыталась использовать ЦП, но не смогла, поскольку все ресурсы ЦП были слишком заняты или иным образом заняты).

**Оптимизация запросов**

В большинстве случаев проблемы с производительностью вызваны низкой производительностью SQL-запросов. При попытке оптимизировать эти запросы возникают многие дилеммы, например, использовать ли IN или EXISTS, писать ли подзапрос или объединение. Можно ускорить запросы SQL с помощью оптимизаторов запросов, которые ускорят запрос и объяснят рекомендации.

**Создать оптимальные индексы**

При правильной индексации можно оптимизировать продолжительность выполнения запроса и повысить общую производительность базы данных. Индексы достигают этого, внедряя структуру данных, которая помогает поддерживать порядок и облегчает поиск информации; в основном, индексирование ускоряет процесс поиска данных и делает его более эффективным, тем самым экономя время (и систему) и усилия.


**Выделить больше памяти**

Подобно тому, как недостаточно мощный процессор может повлиять на эффективность базы данных, так же как и нехватка памяти. В конце концов, когда в базе данных недостаточно памяти для выполнения запрашиваемой работы, производительность базы данных по понятным причинам пойдет на спад. По сути, наличие большего объема памяти поможет повысить эффективность системы и общую производительность. Хороший способ проверить, нужно ли больше памяти, — посмотреть, сколько ошибок в системе имеет страница; Если количество сбоев велико (например, в тысячах), это означает, что хостам не хватает (или, возможно, полностью не хватает) доступного пространства памяти. Кроме того, можно рассмотреть вопрос об увеличении объема памяти, используемой MySQL. Рекомендуется разрешить ему выделять 70% общей памяти (при условии, что база данных является единственным приложением на этом сервере). Можно изменить объем памяти, выделенной для базы данных, используя ключ innodb_buffer_pool_size в файле конфигурации MySQL, my.cnf.

**Дефрагментация данных**

Если присутствуют проблемы с медленной базой данных, другим возможным решением является дефрагментация данных. Когда в базу данных записывается много записей и время идет, записи фрагментируются во внутренних файлах данных MySQL и на самом диске. Дефрагментация диска позволит сгруппировать соответствующие данные, поэтому операции, связанные с вводом/выводом, будут выполняться быстрее, что напрямую повлияет на общую производительность запросов и базы данных. Кроме того, на некотором связанном примечании также важно иметь достаточно дискового пространства вообще, работая с базой данных; если необходимо оптимизировать производительность базы данных, надо использовать дефрагментацию диска, сохраняя при этом достаточно свободного дискового пространства для базы данных.

**Типы дисков**

Для извлечения результатов даже одного запроса могут потребоваться миллионы операций ввода-вывода с диска, в зависимости от объема данных, к которым запрос должен получить доступ для обработки, и в зависимости от объема данных, возвращаемых из запроса. Таким образом, тип дисков на сервере может сильно повлиять на производительность SQL запросов. Работа с SSD-дисками может значительно повысить общую производительность базы данных и, в частности, производительность SQL-запросов.

**Версия базы данных**

Другим важным фактором производительности базы данных является версия MySQL, которая используется в настоящее время. Обновление последней версии базы данных может существенно повлиять на общую производительность базы данных. Возможно, что один запрос может работать лучше в старых версиях MySQL, чем в новых, но если посмотреть на общую производительность, новые версии, как правило, работают лучше.







